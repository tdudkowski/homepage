---
title: "Gatsby cz. 7 - blog MDX cz. 1"
section: "blog"
subsection: "it"
date: 2021-07-31
edited:
image: ../images/Gatsby_Monogram.png
tags: react, gatsby
---

### Wstp

Tworzymy bloga. W tym wpisie przedstawi jak utworzy blog MDX z list wpis贸w i tagami.

MDX jest procesorem Markdowna, kt贸ry dodatkowo umo偶liwia umieszczenie w pliku .mdx dowolnego komponentu. Jest to poczenie mo偶liwoci JSX i prostoty Markdowna.

Do tworzenia cie偶ek u偶yj starego i dobrze znanego pliku gatsby-node.js. Od jesieni 2020 mo偶emy te偶 zastosowa File System Route API, ale w tej chwili nie ma on mo偶liwoci filtrowania i nadaje si do stron, w kt贸rym jest tylko jeden katalog / kategoria z plikami .mdx. Zostanie zaprezentowany na kocu wpisu.

- ["GatsbyJS - Pobieranie danych z GraphQL (Pokedex )" [YT 16:50]](https://www.youtube.com/watch?v=JK18MoOlBOQ) (tutaj u偶yto zewntrznego API, wic by potrzebny plugin gatsby-source-graphql)
- ["GatsbyJS - Generowanie podstron (Pokedex )" [YT 15:52]](https://www.youtube.com/watch?v=bpuUPXdEtjo) - wzmiankowana tu strona to ["Creating and Modifying Pages"](https://www.gatsbyjs.com/docs/creating-and-modifying-pages/)

### Start

Plan wiec przedstawia si nastpujco:

- instalacja i konfiguracja MDX
- utworzenie bloga: pliki wpis贸w w formacie .mdx, GraphQL, gatsby-node.js
- tagi, klikalne z automatycznie generowan list wpis贸w z tym tagiem
- File System Route API

### Instalacja MDX

MDX

```
$ npm i gatsby-plugin-mdx @mdx-js/mdx @mdx-js/react gatsby-source-filesystem
```

gatsby-remark-vscode

```bash
$ npm i gatsby-transformer-remark gatsby-remark-vscode
```

- [MDX](https://mdxjs.com/)
- [gatsby-plugin-mdx](https://www.gatsbyjs.com/plugins/gatsby-plugin-mdx/)
- [gatsby-remark-vscode](https://www.gatsbyjs.com/plugins/gatsby-remark-vscode/)

### Konfiguracja

Na samym pocztku pliku .mdx jest frontmatter. Jest to seria zdefiniowanych p贸l zawierajcych podstawowe dane o pliku, kt贸re dalej bdziemy przetwarza. Jest to bardzo elastyczny mechanizm. Najczciej zawiera tytu, sekcj (ewentualnie podsekcj), dat wpisu, czasem te偶 ostatniej edycji, czasem autora, cie偶k do powizanego z wpisem obrazka i tagi. Mo偶na te偶 tam umieci du偶sze fragmenty tekstu jak np. streszczenie wpisu dodawane w licie wpis贸w.

**/src/blogposts/any-blogpost.mdx**

```
---
title: "Tytu wpisu o Gatsby'm"
section: "blog"
subsection: "it"
date: 2021-07-01
edited: 2021-07-13
img: ../images/gatsby.jpg
tags: react, gatsby
---

### Pierwszy podtytu

Tre...

//
```

Pliki .mdx s w katalogu: /src/blogposts. **Uwaga:** co do zasady wszystkie pliki treci powinnimy trzyma poza /src/pages/. Zapobiega to rysowaniu nadmiarowych cie偶ek. Postan tylko te, kt贸re zdefiniujemy w gastby-node.js. Tre bloga chcesz zaprezentowa na stronie wygenerowanej przy pomocy szablonu i pod adresem url/blog/tytul-wpisu, a nie dodatkowo go tre pod adresem dajmy na to url/blogposts/tytul-wpisu. Ponadto mniej cie偶ek to kr贸tszy czas kompilacji.

**/gatsby-config.js**

```js
        `gatsby-plugin-mdx`,
        {
            resolve: `gatsby-source-filesystem`,
            options: {
                name: `blogpost`,
                path: `${__dirname}/src/blogposts`,
            },
        },
```

#### Plik gatsby-node.js

- Requestem (zapytaniem) GraphQL pobieramy wpisy
- Tworzymy z nich tablic
- Tablic tworzymy strony wpis贸w.

**/src/gatsby-node.js**

```js
const path = require(`path`);

exports.createPages = ({ graphql, actions }) => {
    const { createPage } = actions
    const postTemplate = path.resolve("./src/templates/blogPostTemplate.js");
    return graphql(`	{
    posts: allMdx(
      filter: { fileAbsolutePath: { glob: "**/src/blogposts/*.mdx" } }
      ) {
        nodes {
            frontmatter {
                title
                section
                subsection
                }
            slug
            id
            body
            }
        }
    }
  `).then((result) => {
        if (result.errors) {
            throw result.errors;
        }
        const posts = result.data.posts.nodes;
        posts.forEach(post => {
            createPage({
                path: "/blog/" + post.slug,
                component: postTemplate,
                ...post,
                context: {
                    ...post.context,
                    slug: post.slug,
                },
            });
        });
    });
};
```

#### Szablon wpisu

Szablon wpisu znajduje si w katalogu /src/templates.

- odbiera dane wygenerowane przez gatsby-node.js przez request graphql z koca pliku
- i jako obiekt data propsem przekazuje do swojego wntrza
- do szablonu importowany jest layout z katalogu /src/components

**/src/templates/blogPostTemplate.js**

```js
import React from "react";
import { Link, graphql } from "gatsby";
import { MDXRenderer } from "gatsby-plugin-mdx";
import LayoutBlog from "../components/layout"

const blogPage = ({ data }) => {

    const { frontmatter, id, body, slug } = data.mdx;

    return (
        <LayoutBlog>
            <Link to="/blog">blog main page</Link>
            <h2>{frontmatter.title}</h2>
            <MDXRenderer>{body}</MDXRenderer>
        </LayoutBlog>
    );
};

export default blogPage

export const query = graphql`
  query BlogPageBySlug($slug: String!) {
   mdx( slug: { eq: $slug } ) {
      id
      body
      slug
      frontmatter {
        title
        section
        subsection
      }
    }
  }
`;
```
#### Strona g贸wna bloga

Dziaa w spos贸b analogiczny do powy偶szego szablonu.

**/src/pages/blog.js**

```js
import * as React from 'react'
import {Link, graphql} from "gatsby";
import Layout from "../components/layout"

const BlogPage = ({data}) => {
    return (
        <Layout>
        <h2>blog here</h2>
            <p>Dowolny tekst.</p>

<ul>
            {data.allMdx.nodes.map(({ id, frontmatter, slug }) => (
                <li  key={id}>
                    <Link to={`/blog/${slug}`}>{frontmatter.title}</Link>
                </li>
                            ))}
</ul>
        </Layout>
    )
}

export default BlogPage

export const query = graphql`
query AllPosts {
     allMdx(
      filter: { fileAbsolutePath: { glob: "**/src/blogposts/*.mdx" } }
      ) {
        nodes {
            frontmatter {
                title
                section
                subsection
                }
            slug
            id
            body
        }
    }
}
`;
```

#### Podsumowanie

*Et voil !* Powinno dziaa. Cay schemat operacji wyglda nastpujco:

- U偶ywamy plik贸w .mdx trzymanych w katalogu poza /src/pages; katalog ten musi zosta wskazany przez gatsby-source-filesystem w g贸wnym pliku konfiguracyjnym /gatsby-config.js.
- Dziki powy偶szemu w danych GraphQL pojawiaj si dane wpis贸w.
- W pliku gatsby-node.js pobieramy te dane, tworzymy z nich tablic, a z niej generujemy cie偶ki.
- Dane te pobierane s przez szablon wpisu, do kt贸rego importowany jest layout - tak powstaje strona wpisu.
- Potrzebna jest tak偶e strona g贸wna bloga z list wpis贸w. W najprostszej wersji bdzie to jeden z dw贸ch plik贸w w katalogu /src/pages (drugim jest wymagany 404.js).

Powy偶szy system najczciej jest u偶ywany do tworzenia blog贸w. Ale r贸wnie dobrze mo偶e zosta zastosowany do tworzenia innych stron. Jest to przydatne, je偶eli skadaj si z du偶ej liczby dokument贸w. Je偶eli przenosimy/tworzymy stron z treci w plikach .mdx, musimy si liczy z pewnymi ograniczeniami narzucanymi przez Markdown, kt贸ry ze wzgldu na prostot mo偶e by przetwarzany na HTML w ograniczonym zakresie. Markdown nie ma takich element贸w jak div, span, lista definicyjna, klasy czy id. W przypadku MDX jest to kompensowane mo偶liwoci umieszczania komponent贸w.

Podstawow zalet zastosowania MDX do stron jest atwo i prostota edycji treci oraz generalna prostota struktury strony.

W przypadku stron z niewielk liczb dokument贸w i takich, kt贸re stawiaj na efekty, najlepszym rozwizaniem pozostaje JSX.

### File System Route API vs gatsby-node.js

Jesieni 2020 pojawia si jeszcze jedna mo偶liwo programistycznego tworzenia stron File System Route API. Jest on du偶o prostszy i nie wymaga u偶ycia pliku gatsby-node.js. Na razie jednak nie zastpi gastby-node.js, bo nie ma mo偶liwoci filtrowania danych, wrzuca na tworzony schemat cie偶ek ca tre .mdx, jak znajdzie.

- Gatsby [Announcing Gatsbys new File System Route API](https://www.gatsbyjs.com/blog/fs-route-api/) | [File System Route API](https://www.gatsbyjs.com/docs/reference/routing/file-system-route-api/)

Pocztek, wszystko a偶 do pliku gastby-node.js wyglda identycznie.

W przedstawionym w pierwszym wpisie schemacie strony do wygenerowania cie偶ek i podstron wystarczy nastpujcy schemat

- /src/pages/index.js
- /src/pages/404.js oraz inne podstrony funkcyjne typu about, contact (zwyky JSX)
- /src/pages/{Mdx.frontmatter__section}/
- /src/pages/{Mdx.frontmatter__section}/index.js
- /src/pages/{Mdx.frontmatter__section}/{Mdx.frontmatter__subsection}/
- /src/pages/{Mdx.frontmatter__section}/{Mdx.frontmatter__subsection}/index.js
- /src/pages/{Mdx.frontmatter__section}/{Mdx.frontmatter__subsection}/{mdx.slug}.js

Jak wida do utworzenia dowolnej strony z sekcjami, podsekcjami mogcej zawiera dowoln liczb dokument贸w wystarcz dwa katalogi i pi plik贸w.

**/src/pages/{Mdx.frontmatter__section}/{Mdx.frontmatter__subsection}/{mdx.slug}.js**

```js
import * as React from "react"
import { graphql } from "gatsby"
import { Breadcrumb } from 'gatsby-plugin-breadcrumb'
import { MDXRenderer } from 'gatsby-plugin-mdx'
import Layout from "../../../components/layout"

const ArticlePage = ({ data, pageContext, location }) => {

  const mdx = (data.mdx)

  const {
    breadcrumb: { crumbs },
  } = pageContext

  const regex = new RegExp('(/)(.*?)/')
  const section = location.pathname.match(regex)[2]

  return (
    <Layout section={mdx.frontmatter.section} subsection={mdx.frontmatter.subsection}>
      <Breadcrumb
        location={location}
        crumbs={crumbs}
        crumbSeparator=" / "
        crumbLabel={mdx.frontmatter.title}
      />
      <h2>{title}</h2>
      <MDXRenderer>{body}</MDXRenderer>
    </Layout>
  )
}

export default ArticlePage

export const query = graphql`
query ArticlePageSubsectionQuery($slug: String!) {
  mdx(slug: { eq: $slug }, fileAbsolutePath: {glob: "**/src/pages/articles/*.mdx" }) {
    id
    slug
    body
    frontmatter {
      title
      section
      subsection
    }
  }
}
`;
```

**/src/pages/{Mdx.frontmatter__section}/{Mdx.frontmatter__subsection}/index.js**

```js
import * as React from "react"
import { Link, graphql } from "gatsby"
import Layout from "../../../components/layout"
import { Breadcrumb } from 'gatsby-plugin-breadcrumb'
import { MDXRenderer } from 'gatsby-plugin-mdx'

const ArticlesPage = ({ data, pageContext, location }) => {
    const mdx = (data.allMdx)

    const {
        breadcrumb: { crumbs },
    } = pageContext

    const regex = new RegExp('(/)(.*)/')

    const properMDX = data.allMdx.nodes.filter(item => location.pathname.includes(item.frontmatter.subsection))

    return (
        <Layout section={properMDX[0].frontmatter.section} subsection={properMDX[0].frontmatter.subsection}>
            {/* <IndexSubsection subsection={location.pathname} /> */}

            <Breadcrumb
                location={location}
                crumbs={crumbs}
                crumbSeparator=" / "
                crumbLabel={properMDX[0].frontmatter.title}
            />
            <h2>{properMDX[0].frontmatter.title}</h2>
            <MDXRenderer>{properMDX[0].body}</MDXRenderer>
        </Layout>
    )
}

export default ArticlesPage

export const query = graphql`
    query IndexTestTrue {
        allMdx(filter: {frontmatter: {comment: {eq: "index"}}}) {
            nodes {
              slug
              frontmatter {
                title
                comment
                subsection
                section
              }
              body
              id
            }
          }
  }
`;
```

### Tagi

Potrzebujemy tag贸w: atwych w utrzymaniu, wywietlanych z blogiem i linkujcych do strony z automatycznie generowan list wszystkich wpis贸w z tym samym tagiem.

Najpierw trzeba utworzy pole tagi we frontmatterze, mo偶na to zrobi elegancko jako tablic ze stringami, ale jest to trudne w utrzymaniu, bo atwo zapomnie lub popeni bd. Wystarczy string, w kt贸rym tagi bd oddzielone przecinkami. Mo偶na przy tym zrobi zao偶enie, 偶e zawsze bdziemy u偶ywa maych liter.

**/src/blogposts/any-blogpost.mdx**

```js
---
tags: tag1, tag2, tag3
---
```

W dalszym procesowaniu tego pola trzeba pamita, 偶eby to pole przekaza w requecie graphql. Zao偶enie: mamy ten sam plik gatsby-node.js, kt贸ry jest powy偶ej.

- W gatsby-node najpierw przekazujemy cie偶k do szablonu (o kt贸rym za chwil).
- Potem tworzymy tabel tags ze string贸w pobranych z p贸l tags. Klasyczna ptla form ma najwiksz wydajno.
- Majc ju偶 tabel tags ze wszystkimi unikalnymi tagami zebranymi z requestu graphql, tworzymy cie偶ki dokadnie t sam metod co cie偶ki do wpis贸w blogowych. Prosz zwr贸ci uwag na dodatkowy element "/tags" w cie偶ce dostpu. Zapobiega to sytuacji, kiedy slug wpisu jest identyczny z tagiem. Jest to raczej mao prawdopodobne, ale je偶eli do tego dojdzie, nie dostaniemy si do wpisu.

**/gatsby-node.js**

```js

//

  const tagTemplate = path.resolve("./src/templates/blogTagListTemplate.js");

//

    const tags = []
    for (let i = 0; i < posts.length; i++) {
      const arrOfTags = posts[i].frontmatter.tags.split(",")
      for (let j = 0; j < arrOfTags.length; j++) {
        if (!tags.includes(arrOfTags[j].trim())) {
          tags.push(arrOfTags[j].trim())
        }
      }
    }

//

    tags.forEach(tag => {
      createPage({
        path: "/blog/tag/" + tag,
        component: tagTemplate,
        ...tag,
        context: {
          ...tag.context,
          slug: tag,
        },
      });
    });
```

Szablon

- Pobieramy tag ze cie偶ki
- Na kocu pliku jest taki sam request graphql, jak na g贸wnej stronie bloga. Wystarczy usun te pola, kt贸rych nie bdziemy potrzebowali.
- Ju偶 po inicjalizacji tagu za jego pomoc filtrujemy dane graphql, przekazujc te wpisy, kt贸re maj ten tag do nowej tablicy.
- W efekcie mamy tablic wpis贸w, kt贸re mo偶na mapowa na list.

**/src/templates/blogTagListTemplate.js**

```js

//

const blogPage = ({ data, location }) => {

    const tag = location.pathname.slice(10)
    const filteredPosts = [...data.allMdx.nodes].filter(item => item.frontmatter.tags.includes(tag))

    return (
        <LayoutBlog>
            <article>
                <h2>Strony z tagiem {tag}</h2>
                <section>
                    {filteredPosts.map(({ id, frontmatter, slug }) => (
                        <li key={id}>
                            <Link to={`/blog/${slug}`}>{frontmatter.title}</Link>
                        </li>
                    ))}
                </section>
            </article>
            <aside>
                <Link to="/blog">blog main page</Link>
            </aside>
        </LayoutBlog>
    );
};

export default blogPage

export const query = graphql`
query AllTags {
     allMdx(
      filter: { fileAbsolutePath: { glob: "**/src/blogposts/*.mdx" } }
      sort: { order: ASC, fields: frontmatter___date }
      ) {
        nodes {
            frontmatter {
                title
                tags
            }
            slug
            id
        }
    }
}
`;
```

Na kocu dodajemy list wpis贸w do szablonu wpisu blogowego

**/src/templates/blogPostTemplate.js**

```js

//

const blogPage = ({ data }) => {

  const { frontmatter, id, body, slug } = data.mdx;
  const tagsArray = [...frontmatter.tags.split(",")]

//

<div className="tagsDiv">
    Tagi: <ul>
        {tagsArray.map(tag => <li key={tag}><Link to={`/blog/tag/${tag.trim()}`}>{tag.trim()}</Link></li>)}
    </ul>
</div>

//

```

W efekcie mamy sytuacj, w kt贸rej przy ka偶dym wpisie pojawia si lista klikalnych tag贸w, ka偶dy kieruje do automatycznie generowanej strony z list link贸w wszystkich wpis贸w majcych ten tag.

### Odnoniki

- [Working with Images in Markdown Posts and Pages](https://www.gatsbyjs.com/docs/working-with-images-in-markdown/)

